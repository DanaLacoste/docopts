#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set ts=4 sw=4 sts=4 et:

import os
import sys
import tempfile

from docopt import docopt, DocoptExit

# docopt prints the help and version messages to standard output by default,
# so we need to redirect it to standard error temporarily to get the documented
# behavior
stdout = sys.stdout
sys.stdout = sys.stderr

try:
    pages = sys.stdin.read().split('\f', 1)
    args = docopt(doc           = pages[0],
                  argv          = sys.argv[1:],
                  help          = True,
                  version       = pages[1].strip() if len(pages) > 1 else None,
                  options_first = 'POSIXLY_CORRECT' in os.environ)
except DocoptExit as e:
    # as DocoptExit is a subclass of SystemExit, but thrown only for incorrect
    # invocations, we need to catch-and-throw it here to get the documented
    # behavior
    sys.exit(e)
except SystemExit as e:
    # docopt exits with sys.exit() when it encounters --help or
    # --version, so we need to catch it and exit with status 2 to get the
    # documented behavior
    sys.exit(2)
except Exception as e:
    # on any other error condition, we just try exiting with something prettier
    # than a stack trace
    sys.exit("%s: %s" % (sys.argv[0], e))

sys.stdout = stdout

tempdir = tempfile.mkdtemp(prefix="docopts-")
for arg, value in args.items():
    path = os.path.join(tempdir, arg)
    if isinstance(value, list):
        os.mkdir(path, 448) # user only read, write, execute
        for i,v in enumerate(value):
            with open(os.path.join(path, str(i+1)), 'w') as f:
                f.write(v)
    elif isinstance(value, str):
        with open(path, 'w') as f:
            f.write(value)
    elif isinstance(value, bool):
        if value:
            open(path, 'w').close()
    elif isinstance(value, int):
        with open(path, 'w') as f:
            f.write(str(value))

print(tempdir)
